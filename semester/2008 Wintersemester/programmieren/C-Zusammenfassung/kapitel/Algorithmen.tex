\part{Algorithmen und Datenstrukturen}
\chapter{Sortierung}
\index{Sortierung}
\section{Bubblesort}
\index{Bubblesort}
\subsection{Beschreibung}
Bubblesort ist die einfachste Art, eine Liste zu sortieren. Der Algorithmus vergleicht immer zwei nebeneinander liegende Elemente und vertauscht die beiden, falls das rechte kleiner ist, als das linke. Der Name kommt daher, dass die großen Werte wie Blasen aufsteigen und nach rechts wandern.

Da nach jedem Durchlauf der Liste das größte Element ganz rechts steht, muss man nur noch eine um ein Element kürzere Liste sortieren. Somit muss man nur genauso oft durch die Liste gehen, wie sie Elemente hat.

\subsection{Algorithmus}
\cfromfile{sourcecodes/Algorithmen/bubblesort.c}

\subsection{Laufzeit-Komplexität}
Für eine Liste mit $n$ Elementen benötigt Bubblesort $O(n^2)$ Vergleichsoperationen.

\subsection{Stabilität}
Bubblesort ist ein stabiler Sortieralgorithmus. Das bedeutet, dass in der sortierten Liste zwei gleiche Elemente in der gleichen Reihenfolge liegen wie in der unsortierten Liste.

\section{Quicksort}
\index{Quicksort}
\subsection{Beschreibung}
\subsection{Algorithmus}
\cfromfile{sourcecodes/Algorithmen/quicksort.c}

\subsection{Laufzeit-Komplexität}
Die Effizienz von Quicksort ist stark von der Wahl des Pivot-Elements abhängig. In der kanonischen Implementierung verwendet man das erste Element der Liste als Pivot. Dies liefert jedoch im Fall einer bereits sortierten Liste die schlechteste Laufzeit.

Quicksort hat im Mittel eine Laufzeit von $O(n \mal \log{n})$, im schlechtesten Fall eine Laufzeit von $O(n^2)$.

\subsubsection{Andere Methoden, das Pivot-Element zu wählen}
\begin{itemize}
\item Zufällige Auswahl eines Pivot-Elements
\item Zufällige Auswahl mehrerer möglicher Pivot-Elemente, der Median der Kandidaten wird dann verwendet
\item \dots
\end{itemize}

\subsection{Standardbibliothek}
Die \inlinec{C}-Standardbibliothek bietet eine Implementierung von quicksort an. Diese ist in \inlinec{stdlib.h} als \inlinec{qsort()} deklariert. Wie alle generischen Implementierungen in \inlinec{C} verwendet sie Funktionszeiger. Dies wirkt sich allerdings negativ auf die Laufzeit aus.

\section{Mergesort}
\index{Mergesort}
\subsection{Beschreibung}
Mergesort ist ein Divide-and-Conquer-Sortierverfahren. Eine Liste der Länge n wird solange rekursiv geteilt, bis n einelementige Teillisten entstehen. Nun folgt der eigentliche Sortiervorgang: Man nimmt immer zwei Teillisten und fügt diese zu einer neuen sortierten Teilliste zusammen, indem man immer das kleinste Element der beiden Listen streicht und in die neue Teilliste einfügt. Dieses Verfahren muss dann solange wiederholt werden, bis es nur noch eine Teilliste gibt.

\subsection{Algorithmus}
\cfromfile{sourcecodes/Algorithmen/mergesort.c}
Mergesort wird hier als Funktion realisiert, der zwei Parameter - das zu sortierende Array und dessen Länge - übergeben werden. Die if-Abfrage in der ersten Zeile des Funktionsrumpfes führt zum Rekursionsabbruch: Falls das Array nur aus einem Element besteht, muss es nicht sortiert werden. Andernfalls werden die Werte des Arrays in zwei Teilarrays kopiert, die anschließend durch rekursive Aufrufe von Mergesort sortiert werden. Nach dem Sortieren werden die beiden Teilarrays zusammengefügt. Für beide Teilarrays wird jeweils ein Pointer angelegt, der immer auf das kleinste Element, das noch nicht in das große Array eingefügt wurde, zeigt. Da die Teilarrays sortiert sind, muss dazu lediglich nach jedem Einfügen der Zeiger auf die nächste Stelle gesetzt werden. Möglich ist das natürlich nur, solange sich noch in beiden Arrays Elemente befinden, die noch nicht in das große Array kopiert wurden. Wenn das Ende eines der beiden Teilarrays erreicht ist, dann müssen noch alle restlichen Elemente des anderen Teilarrays durchlaufen und der Reihe nach in das große Array kopiert werden. Um das zu erreichen, wird der Zeiger des abgearbeiteten Arrays auf die letzte Stelle des anderen Teilarrays gesetzt.

\subsection{Laufzeit-Komplexität}
Die Komplexität des Algorithmus ist $O(n \mal \log{n})$.

\chapter{Felder}
Felder, auch Arrays oder Vektoren genannt, sind eindimensionale Datenstrukturen, welche Daten von demselben Typ beinhalten. Die Größe eines Feldes ist konstant, weswegen man hier auch von statischen Datenstrukturen spricht. In der Praxis ist dieser Aspekt von untergeordneter Bedeutung, denn jedes Feld lässt sich nahezu beliebig verändern. Diese Datenstruktur wird gerne bei Editoren benutzt.

\section{Aufbau eines Feldes}
Das folgende Beispiel zeigt, wie man ein Feld aufbaut:
\begin{lstlisting}[frame=single, firstnumber=auto, numbers=left, stepnumber=2, numbersep=10pt, emph={strcpy}, emphstyle={\color{blue}\bf}]
#include <stdio.h>

void drucke_array (int a[], int anz)
{
  int i;
  for (i = 0; i < anz; i++)
    printf ("%2d ", a[i]);
  printf ("\n");
}

int main (void)
{
  int array[10];
  int i;
  for (i = 0; i < 10; i++)
    array[i] = 10 - i;
  drucke_array (array, 10);
  return 0;
}
\end{lstlisting}
Hier ist array unsere zu betrachtende Datenstruktur, die Größe ist vorgegeben auf 10 Werte vom Typ Integer. Die Ausgabe des Programmes lautet:
\begin{lstlisting}[frame=single, emph={strcpy}, emphstyle={\color{blue}\bf}]
10  9  8  7  6  5  4  3  2  1
\end{lstlisting}

\section{Sortieren}
Um ein die Elemente eines Arrays zu sortieren, sollte man sich vorhandener Sortieralgorithmen bedienen. Ein Sortieralgorithmus ist Bubblesort, welcher als Codesegment hier dargestellt ist:
\begin{lstlisting}[frame=single, firstnumber=auto, numbers=left, stepnumber=2, numbersep=10pt, emph={strcpy}, emphstyle={\color{blue}\bf}]
#include <stdio.h>

void drucke_array (int a[], int anz)
{
  int i;
  for (i = 0; i < anz; i++)
    printf ("%2d ", a[i]);
  printf ("\n");
}

void sortiere_vertausche (int a[], int anz)
{
  int i, vertauscht, hilf;
  vertauscht = 1;
  while (vertauscht)
    {
      vertauscht = 0;
      for (i = 1; i < anz; i++)
        {
          if (a[i-1] > a[i])
            {
              hilf = a[i-1];
              a[i-1] = a[i];
              a[i] = hilf;
              vertauscht = 1;
            }
        }
      drucke_array (a, anz);
    }
}

int main (void)
{
  int array[10];
  int i;
  for (i = 0; i < 10; i++)
    array[i] = 10 - i;
  drucke_array (array, 10);
  sortiere_vertausche (array, 10);
  drucke_array (array, 10);
  return 0;
}
\end{lstlisting}
Die Ausgabe des Programmes ist wie folgt:
\begin{lstlisting}[frame=single, emph={strcpy}, emphstyle={\color{blue}\bf}]
10  9  8  7  6  5  4  3  2  1   # unsortiert
 9  8  7  6  5  4  3  2  1 10
 8  7  6  5  4  3  2  1  9 10
 7  6  5  4  3  2  1  8  9 10
 6  5  4  3  2  1  7  8  9 10
 5  4  3  2  1  6  7  8  9 10
 4  3  2  1  5  6  7  8  9 10
 3  2  1  4  5  6  7  8  9 10
 2  1  3  4  5  6  7  8  9 10
 1  2  3  4  5  6  7  8  9 10
 1  2  3  4  5  6  7  8  9 10   # sortiert
 1  2  3  4  5  6  7  8  9 10
\end{lstlisting}
Nach 10-maligem durchlaufen der while-Schleife ist das Zahlenarray sortiert. Da zu jeder while-Schleife ein 10-maliges Durchlaufen der for-Schleife gehört, wird das Array nahezu 100-mal durchlaufen.

\section{Einfügen}
Um in ein Array an einer Position etwas einzufügen, müssen alle Elemente rechts von der Einfügeposition nach rechts geschoben werden:
\begin{lstlisting}[frame=single, emph={strcpy}, emphstyle={\color{blue}\bf}]
abcdefg
  ^ Einfügeposition, Zeichen 'X'
ab cdefg
abXcdefg
\end{lstlisting}
Alternativ können wir natürlich auch an das Ende einfügen. Die folgende Funktion verdeutlicht das:
\begin{lstlisting}[frame=single, firstnumber=auto, numbers=left, stepnumber=2, numbersep=10pt, emph={strcpy}, emphstyle={\color{blue}\bf}]
void einfuegen (int a[], int *anzahl, int wert, int pos)
{
  int anz = (*anzahl);
  int i;
  if (pos < anz)
    {
      for (i = anz; i > pos; i--)
        a[i] = a[i-1];
      a[i] = wert;
      (*anzahl)++;
    }
  else if (pos == anz)
    {
      a[pos] = wert;
      (*anzahl)++;
    }
}
\end{lstlisting}
Wenn die Einfügeposition (\inlinec{pos}) kleiner ist als die Anzahl der Zeichen (\inlinec{anzahl}) im Array (\inlinec{a}) dann schiebe alle Arrayelemente ab Einfügeposition nach recht und füge das Element (\inlinec{wert}) ein. Sonst hänge das Element an das Ende des Arrays.
\textbf{Bitte beachten Sie, dass wir hier von einem \textit{beliebig großen} Array ausgehen. Selbstverständlich können wir das Programm zum Absturz bringen, wenn wir über die Arraygrenzen hinweg einfügen.}

\section{Löschen}
Wollen wir ein Element aus dem Array löschen, so genügt es, alle Elemente rechts um eine Position nach links zu verschieben und die Anzahl der vorhandenen Zeichen im Array um eines zu vermindern. Etwa so:
\begin{lstlisting}[frame=single, emph={strcpy}, emphstyle={\color{blue}\bf}]
abcdefg
  ^ Löschindex
abdefg
\end{lstlisting}
Hier der Code:
\begin{lstlisting}[frame=single, firstnumber=auto, numbers=left, stepnumber=2, numbersep=10pt, emph={strcpy}, emphstyle={\color{blue}\bf}]
void loeschen (int a[], int *anzahl, int index)
{
  int anz = (*anzahl);
  int i;
  if (index < anz)
    {
      for (i = index + 1; i < anz; i++)
        a[i-1] = a[i];
      (*anzahl)--;
    }
}
\end{lstlisting}
\textbf{Auch diese Funktion nimmt keine Rücksicht auf Arraygrenzen, die in diesem Beispiel durchaus negativ sein dürfen.}
